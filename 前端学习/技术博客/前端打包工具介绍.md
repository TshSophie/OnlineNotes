## 基本概念

历史上先后出现了一系列构建工具，它们各有优缺点。由于前端工程师很熟悉JavaScript，Node.js又可以胜任所有构建需求，所以大多数构建工具都是用Node.js开发的。

前端技术发展之快，各种可以提高开发效率的新思想和框架层出不穷。但是它们都有一个共同点：源代码无法直接运行，必须通过转换后才可以正常运行。

构建就是做这件事情，将源代码转换成可执行的JavaScript、CSS、HTML代码，包括如下内容。

- 代码转换：将TypeScript编译成JavaScript、将SCSS编译成CSS等。

- 文件优化：压缩JavaScript、CSS、HTML代码，压缩合并图片等。

- 代码分割：提取多个页面的公共代码，提取首屏不需要执行部分的代码让其异步加载。

- 模块合并：在采用模块化的项目里会有很多个模块和文件，需要通过构建功能将模块分类合并成一个文件。

- 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。

- 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。

- 自动发布：更新代码后，自动构建出线上发布代码并传输给发布系统。


构建其实是工程化、自动化思想在前端开发中的体现，将一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。构建为前端开发注入了更大的活力，解放了我们的生产力。



## 常用打包工具

- gulp：是一个多任务得构建工具，跟jq很像找到一个文件做一系列得操作形成一个任务，整个就是一个任务得集合

- rollup：适用于基础库的打包，基于ES6打包，打包文件小且干净，执行效率更高，vue、react都是基于他打包的
- webpack: 适用于大型的项目，开始就需要通过入口文件开始打包，一次性加载所有的资源。
- vite：实时的打包，开始不会进行打包，所以启动非常快，直接请求所需模块并实时编译



### gulp使用介绍

本教程使用的版本是gulp4

#### **安装 gulp 命令行工具**

```shell
npm install --global gulp-cli
```

#### **安装 gulp，作为开发时依赖项**

```shell
npm install --save-dev gulp
```

#### **创建 gulpfile 文件**

利用任何文本编辑器在项目大的根目录下创建一个名为 gulpfile.js 的文件，并在文件中输入以下内容：

```js
function defaultTask(cb) {
  // place code for your default task here
  cb();
}

exports.default = defaultTask
```


#### **创建任务**

每个 gulp 任务（task）都是一个异步的 JavaScript 函数，此函数是一个可以接收 callback 作为参数的函数，或者是一个返回 stream、promise、event emitter、child process 或 observable 类型值的函数。由于某些平台的限制而不支持异步任务，因此 gulp 还提供了一个漂亮 替代品。

##### **导出任务**

任务（tasks）可以是 **public（公开）** 或 **private（私有）** 类型的。

- **公开任务（Public tasks）** 从 gulpfile 中被导出（export），可以通过 `gulp` 命令直接调用。
- **私有任务（Private tasks）** 被设计为在内部使用，通常作为 `series()` 或 `parallel()` 组合的组成部分。

一个私有（private）类型的任务（task）在外观和行为上和其他任务（task）是一样的，但是不能够被用户直接调用。如需将一个任务（task）注册为公开（public）类型的，只需从 gulpfile 中导出（export）即可。

> 注：*在以前的 gulp 版本中，*`task()` *方法用来将函数注册为任务（task）。虽然这个 API 依旧是可以使用的，但是 导出（export）将会是主要的注册机制，除非遇到 export 不起作用的情况。*

```js
const { series } = require('gulp');

// `clean` 函数并未被导出（export），因此被认为是私有任务（private task）。
// 它仍然可以被用在 `series()` 组合中。
function clean(cb) {
  // body omitted
  cb();
}

// `build` 函数被导出（export）了，因此它是一个公开任务（public task），并且可以被 `gulp` 命令直接调用。
// 它也仍然可以被用在 `series()` 组合中。
function build(cb) {
  // body omitted
  cb();
}

exports.build = build;
exports.default = series(clean, build);
```

##### **组合任务**

Gulp 提供了两个强大的组合方法： `series()` 和 `parallel()`，允许将多个独立的任务组合为一个更大的操作。这两个方法都可以接受任意数目的任务（task）函数或已经组合的操作。`series()` 和 `parallel()` 可以互相嵌套至任意深度。

如果需要让任务（task）按顺序执行，请使用 `series()` 方法。

```js
const { series } = require('gulp');

function transpile(cb) {
  // body omitted
  cb();
}

function bundle(cb) {
  // body omitted
  cb();
}

exports.build = series(transpile, bundle);
```

对于希望以最大并发来运行的任务（tasks），可以使用 `parallel()` 方法将它们组合起来。

```js
const { parallel } = require('gulp');

function javascript(cb) {
  // body omitted
  cb();
}

function css(cb) {
  // body omitted
  cb();
}

exports.build = parallel(javascript, css);
```

#### **运行gulp任务**

只需切换到存放gulpfile.js文件的目录，然后在命令行中执行gulp或gulp taskName命令就行了。

```shell
# 执行默认任务
gulp 
# 执行指定任务
gulp taskName
```



### rollup使用介绍

 Rollup.js是一个模块打包工具，可以帮助你从一个入口文件开始，将所有使用到的模块文件都打包到一个最终的发布文件中（极其适合构建一个工具库，这也是选择用rollup来打包的原因）。与传统的 CommonJS 和 AMD 这一类非标准化的解决方案不同，Rollup 使用的是 ES6 版本 JavaScript 中的模块标准。Rollup.js一个重要特性叫做'tree-shaking'，这个特性可以帮助你将无用代码（即没有使用到的代码）从最终的生成文件中删去。（这个特性是基于ES6模块的静态分析的，也就是说，只有export而没有import的变量是不会被打包到最终代码中的）

有了 Rollup，你现在就可以放心地使用新的模块标准来书写代码，并将其编译为当前被广泛支持的 CommonJS、AMD 以及 IIFE 风格等多种格式。

#### 安装rollup命令行工具

```shell
npm install --global rollup
```

这样安装可以让 Rollup 成为全局可用的命令行，你也可以仅将其安装于本地，详见本地化安装 Rollup 。

当处于团队合作或分布式环境时，添加 Rollup 作为本地依赖是非常适合的。安装本地 Rollup ，多个贡献者不需要再单独安装 Rollup, 保证所有贡献者使用相同的 Rollup 版本。

```shell
npm install rollup --save-dev
```



#### 快速开始

Rollup 可以通过两种方式使用：使用[命令行](https://www.rollupjs.com/guide/command-line-reference)方式，可以为命令行传入一个可选的配置文件。或者使用 [JavaScript API](https://www.rollupjs.com/guide/javascript-api) 方式。运行 `rollup --help` 可以查看可用的选项和参数。

以下命令假设你以 `main.js` 文件作为应用的入口点，并将所有的引入编译为单文件 `bundle.js`。

**用于浏览器：**

```text
# 编译为一个在 <script> 标签中可用的自运行函数 ('iife')
rollup main.js --file bundle.js --format iife
```

**用于 Node.js：**

```text
# 编译为 CommonJS 模块 ('cjs')
rollup main.js --file bundle.js --format cjs
```

**同时用于浏览器和 Node.js：**

```text
# 需要为 UMD 格式的包指定一个名称
rollup main.js --file bundle.js --format umd --name "myBundle"
```

#### Rollup 配置文件

配置文件是一个ES6模块，它对外暴露一个对象，这个对象包含了一些Rollup需要的一些选项。通常，我们把这个配置文件叫做`rollup.config.js`，它通常位于项目的根目录。

```shell
# 生成一个配置文件
npx rollup --config
```

Rollup 的配置文件并不是必须的，但是配置文件非常强大而且很方便，所以我们**推荐你能够使用**。配置文件是一个 ES 模块，它对外导出一个对象，这个对象配置了我们想要的一些选项：

```javascript
export default {
  # 输入文件
  input: 'src/main.js',
  output: {
    # 输出文件名
    file: 'bundle.js',
    # 输出文件格式
    format: 'cjs'
  }
};
```

Rollup 将会在配置文件被依赖之前，在后台将配置文件和 CommonJS 的相关依赖项进行转译和打包，这样做的优点就是你可以与 ES 模块代码库共享代码，同时与 Node 生态完全互通。

##### 常用配置项

###### input

类型：`string | string [] | { [entryName: string]: string }`
命令行参数：`-i`/`--input <filename>`

该选项是指 bundle 的入口文件，比如你的 `main.js` 或 `app.js` 或 `index.js` 文件。如果你使用数组或者对象作为 input 的值，那么它们将被打包到独立的输出区块（chunks）。除非使用 [`output.file`](https://www.rollupjs.com/guide/big-list-of-options#outputfile) 选项，否则生成的区块名称会根据 [`output.entryFileNames`](https://www.rollupjs.com/guide/big-list-of-options#outputentryfilenames) 选项来确定。该选项值为对象形式时，对象的键将作为文件名中的 `[name]`，而对于值为数组形式，数组的值将作为入口的文件名。

###### output.dir

类型：`string`
命令行参数：`-d`/`--dir <dirname>`

该选项用于指定所有生成 chunk 文件所在的目录。如果生成多个 chunk，则此选项是必须的。否则，可以使用 `file` 选项代替。

###### output.file

类型：`string`
命令行参数：`-o`/`--file <filename>`

该选项用于指定要写入的文件名。如果该选项生效，那么同时也会生成源码映射（sourcemap）文件。只有当生成的 chunk 不超过一个时，该选项才会生效。

###### output.format

类型：`string`
命令行参数：`-f`/`--format <formatspecifier>`

该选项用于指定生成 bundle 的格式。可以是以下之一：

- `amd` - 异步模块定义，适用于 RequireJS 等模块加载器
- `cjs` - CommonJS，适用于 Node 环境和其他打包工具（别名：`commonjs`）
- `es` - 将 bundle 保留为 ES 模块文件，适用于其他打包工具以及支持 `<script type=module>` 标签的浏览器（别名: `esm`，`module`）
- `iife` - 自执行函数，适用于 `<script>` 标签。（如果你要为你的应用创建 bundle，那么你很可能用它。）
- `umd` - 通用模块定义，生成的包同时支持 `amd`、`cjs` 和 `iife` 三种格式
- `system` - SystemJS 模块加载器的原生格式（别名: `systemjs`）

###### output.globals

类型：`{ [id: string]: string } | ((id: string) => string)`
命令行参数：`-g`/`--globals <external-id:variableName,another-external-id:anotherVariableName,...>`

该选项用于使用 `id: variableName` 键值对指定的、在 `umd` 或 `iife` 格式 bundle 中的外部依赖。下面就是一个外部依赖的例子：

```js
import $ from 'jquery';
```

在这个例子中，我们想要告诉 Rollup `jquery` 是外部依赖，并且 `jquery` 模块的 ID 为全局变量 `$`：

```js
// rollup.config.js
export default {
  ...,
  external: ['jquery'],
  output: {
    format: 'iife',
    name: 'MyBundle',
    globals: {
      jquery: '$'
    }
  }
};
```

###### output.plugins

类型：`OutputPlugin | (OutputPlugin | void)[]`

该选项用于指定输出插件，这是设置插件的唯一入口。你查看 [Using output plugins](https://www.rollupjs.com/guide/big-list-of-options#using-output-plugins) 了解更多关于如何设置指定输出插件的信息，另外，[Plugins](https://www.rollupjs.com/guide/plugin-development) 会告诉你如何写一个你自己的插件。对于从包中引入的插件，请记住要调用引入的函数（例如，应该使用 `commonjs()`，而不是 `commonjs`）。返回值为 Falsy 的插件将会被忽略，这样可以用于灵活启用和禁用插件。

```js
// rollup.config.js
import {terser} from 'rollup-plugin-terser';

export default {
  input: 'main.js',
  output: [
    {
      file: 'bundle.js',
      format: 'es'
    },
    {
      file: 'bundle.min.js',
      format: 'es',
      plugins: [terser()]
    }
  ]
};
```



#### 执行rollup

如果你想使用 Rollup 的配置文件，可以在命令行加上 `--config` 或者 `-c` 的选项。

```text
# 将自定义配置文件的路径传给 Rollup
rollup --config my.config.js

# 如果你不传文件名, Rollup将会尝试
# 按照以下顺序加载配置文件：
# rollup.config.mjs -> rollup.config.cjs -> rollup.config.js
rollup --config
```



## 参考

- https://juejin.cn/post/7103150432410681381
- https://www.gulpjs.com.cn
- https://www.rollupjs.com
- JS打包工具rollup——完全入门指南 https://blog.csdn.net/sd19871122/article/details/109621194

