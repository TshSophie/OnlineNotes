## 什么是虚拟DOM？

虚拟DOM（Virtual   Dom），也就是我们常说的虚拟节点，是用JS对象来模拟真实DOM中的节点，该对象包含了真实DOM的结构及其属性，用于对比虚拟DOM和真实DOM的差异，从而进行局部渲染来达到优化性能的目的。

```html
<div class="box">
  <h3>我是一个标题</h3>
  <ul>
    <li>牛奶</li>
    <li>咖啡</li>
    <li>可乐</li>
  </ul>
</div>
```

```js
{
  "sel": "div",
  "data": {
    "class": {
      "box": true
    }
  },
  "children": [
    {
      "sel": "h3",
      "data": {},
      "text": "我是一个标题"
    },
    {
      "sel": "ul",
      "data": {},
      "children": [
        {
          "sel": "li",
          "data": {},
          "text": "牛奶"
        },
        {
          "sel": "li",
          "data": {},
          "text": "咖啡"
        },
        {
          "sel": "li",
          "data": {},
          "text": "可乐"
        }
      ]
    }
  ]
}

```

## 虚拟DOM的作用是什么？

兼容性好。因为Vnode本质是JS对象，所以不管Node还是浏览器环境，都可以操作；
减少了对Dom的操作。页面中的数据和状态变化，都通过Vnode对比，只需要在比对完之后更新DOM，不需要频繁操作，提高了页面性能；


## 虚拟DOM和真实DOM的区别？

说到这里，那么虚拟DOM和真实DOM的区别是什么呢？总结大概如下：

- 虚拟DOM不会进行回流和重绘；
- 真实DOM在频繁操作时引发的回流重绘导致性能很低；
- 虚拟DOM频繁修改，然后一次性对比差异并修改真实DOM，最后进行依次回流重绘，减少了真实DOM中多次回流重绘引起的性能损耗；
- 虚拟DOM有效降低大面积的重绘与排版，因为是和真实DOM对比，更新差异部分，所以只渲染局部；


## 虚拟DOM是如何实现的降低操作真实DOM的频率的？

当数据变化时，vue如何来更新视图的？其实很简单，一开始会根据真实DOM生成虚拟DOM，当虚拟DOM某个节点的数据改变后会生成一个新的Vnode，然后采用DOM Diff算法对VNode和oldVnode进行比较，算出应该如何最小量更新，最后反映到真正的DOM上，最后再使得oldVnode的值为Vnode，因此diff是发生在虚拟DOM上的diff


## 以snabbdom的源码为例进行探究

snabbdom是著名的虚拟DOM库，是diff算法的鼻祖，Vue源码借鉴了snabbdom；

官方git：https://github.com/snabbdom/snabbdom

npm: npm i -D snabbdom

### 主要从以下三个方面进行探究

- 研究1：虚拟DOM如何被渲染函数（h函数）产生？我们要手写h函数
- 研究2：diff算法原理
- 研究3：虚拟DOM如何通过diff变为真正的DOM的(事实上，虚拟DOM变回真正的DOM，是涵盖在diff算法里面的)

> DOM如何变为虚拟DOM，属于模板编译原理范畴，在此不做探究


## h函数-产生Vnode虚拟节点
- 形态① h('div', {}, '文字')
- 形态② h('div', {}, [])
- 形态③ h('div', {}, h())

**虚拟节点的属性**
```json
{
  children: undefined,
  data: {},
  elm: undefined,
  key: undefined,
  sel: "div",
  text: "文字"
}
```


- 如调用 h('a', {props: {href: 'http://www.baidu.com'}}, '百度)
得到：

```json
{"sel": "a", "data":{"props": {"href": "http://www.baidu.com"}}, "text": "百度"}
```

- 如调用h('ul', {}, 
[
  h('li', {}, '苹果'),
  h('li', {}, '香蕉'),
  h('li', {}, '梨子'),
]
)
```html
<ul>
  <li>苹果</li>
  <li>香蕉</li>
  <li>梨子</li>
</ul>
```

- 如调用h('div', {}, h('a', {props: {href: 'http://www.baidu.com'}}, '百度))
```html
<div>
  <a href="http://www.baidu.com">百度</a>
</div>
```

### 实现h函数
```js
// 单个vnode节点构造函数
function vnode(sel, data, children, text, elm){
  const key = data.key
  return {sel, children, text, elm, key}
}

// 
function h(sel, data, c){
  if(arguments.length !=3){
    throw new Error('h函数必须传入3个参数！')
  }
  // 节点内容为文本节点
  if(typeof c == 'string' || typeof c == 'number') {
    return vnode(sel, data, undefined, c, undefined)
    
  // 节点内容为子节点数组 
  } else if(Array.isArray(c)) {
    let children = []
    for (let i = 0; i < c.length; i++) {
      if(!(typeof c[i] == 'object' && c[i].hasOwnProperty('sel')))
        throw new Error('第三个参数类型不对')
      children.push(c[i])
    }
    return vnode(sel, data, children, undefined, undefined)

  // 节点内容为h函数返回的vnode
  } else if(typeof c == 'object' && c.hasOwnProperty('sel')) {
    let children = [c]
    return vnode(sel, data, children, undefined, undefined)
  } else {
    throw new Error('第三个参数类型不对')
  }
}
```


## patch函数，Vnode虚拟节点挂载到真实DOM树
patch(oldVnode, newVnode)函数的逻辑：
- oldVnode和newVnode是否是同一个节点
  + 是则需要进行精细化的比较
  + 否则，创建newVnode的真实dom，并将其插入到旧节点之前

```js
// patch Vnode虚拟节点挂载到真实DOM树
function patch(oldVnode, newVnode) {
  // 判断第一个参数是dom节点还是虚拟节点
  if(oldVnode.sel == '' || oldVnode.sel == undefined) {
    // 如果是dom节点，创建虚拟节点
    oldVnode = vnode(oldVnode.tagName.toLowerCase(), {}, [], undefined, oldVnode);
  }
  // 判断oldVnode和newVnode是否是同一个节点
  if(oldVnode.key == newVnode.key && oldVnode.sel == newVnode.sel) {
    // 是同一个节点，进行精细化比较
    patchVnode(oldVnode, newVnode)
  } else {
    // 不是同一个节点则创建newVnode的真实dom，并将其插入到旧节点之前
    let newVnodeElm = createElement(newVnode);
    // 将新节点插入到旧节点之前
    if(oldVnode.elm && newVnodeElm) {
      oldVnode.elm.parentNode.insertBefore(newVnodeElm, oldVnode.elm);
    }
  }
}

```


### createElement函数，虚拟节点转为真实DOM
```js
// createElement 将虚拟节点变为dom
function createElement(vnode) {
  let domNode = document.createElement(vnode.sel);
  // 有子节点还是文本
  if(vnode.text != '' && (vnode.children == undefined || vnode.children.length == 0)) {
    domNode.innerText = vnode.text;
  
  // 它内部是子节点，需要递归创建节点    
  } else if(Array.isArray(vnode.children) && vnode.children.length > 0) {
    for (let i = 0; i < vnode.children.length; i++) {
      // 子节点
      let ch = vnode.children[i];
      // 创建出子节点的dom
      let chDOM = createElement(ch);
      domNode.appendChild(chDOM);
    }
  }
  // 补充elm属性
  vnode.elm = domNode;
  // elm是一个纯dom对象
  return vnode.elm
}
```
### patchVnode函数，相同节点的子节点比较
```js
function patchVnode(oldVnode, newVnode) {  
  // 判断新节点是不是text
  if(newVnode.text != '' && (newVnode.children == undefined || newVnode.children.length == 0)) {
    if(newVnode.text != oldVnode.text) {
      // 将新节点覆盖旧节点
      oldVnode.elm.innerText = newVnode.text;
    }
    // 有子节点
  } else if(Array.isArray(newVnode.children) && newVnode.children.length > 0){
    // 旧节点有子节点
    if(oldVnode.children != undefined && oldVnode.children.length > 0) {
      // 子节点精细化比较
      updateChildren(oldVnode.elm, oldVnode.children, newVnode.children);
    // 旧节点是文本节点
    } else {
      // 清空老节点内容
      oldVnode.elm.innerHTML = ''
      for (let i = 0; i < newVnode.children.length; i++) {
        let dom = createElement(newVnode.children[i]);
        // 上树
        oldVnode.elm.appendChild(dom);
      }
    }
  }
}
```

### updateChildren函数，节点diff算法的实现
四种命中策略


```js
// 判断是否是同一个节点
function checkSameVnode(a, b){
  return a.sel == b.sel && a.key == b.key;
}


```

## 参考文章
https://www.jb51.net/article/194147.htm